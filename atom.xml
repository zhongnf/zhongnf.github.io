<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鸿渐博客</title>
  
  
  <link href="https://zhongnf.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhongnf.github.io/"/>
  <updated>2021-12-13T07:58:26.854Z</updated>
  <id>https://zhongnf.github.io/</id>
  
  <author>
    <name>Zhong hongjian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA多线程基础面试题</title>
    <link href="https://zhongnf.github.io/2021/12/11/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhongnf.github.io/2021/12/11/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-12-11T09:38:06.000Z</published>
    <updated>2021-12-13T07:58:26.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java线程实现-创建方式"><a href="#1-Java线程实现-创建方式" class="headerlink" title="1.Java线程实现/创建方式"></a>1.Java线程实现/创建方式</h2><h3 id="1-1-继承Thread类"><a href="#1-1-继承Thread类" class="headerlink" title="1.1 继承Thread类"></a>1.1 继承Thread类</h3><p>Thread本质上也是实现了Runnable接口的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-实现Runable接口"><a href="#1-2-实现Runable接口" class="headerlink" title="1.2 实现Runable接口"></a>1.2 实现Runable接口</h3><p>如果自己的类已经extends另一个类，就无法直接extends Thread，此时，必须实现一个Runnable接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#1-3-使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="1.3 使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>1.3 使用ExecutorService、Callable、Future实现有返回结果的多线程</h3><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务 返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span></span><br><span class="line"><span class="function">    InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> taskSize = <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// 创建一个线程池</span></span><br><span class="line">   ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">   <span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">   List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">    Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">// 执行任务并获取Future对象</span></span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    <span class="comment">// System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString());</span></span><br><span class="line">    list.add(f);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 关闭线程池</span></span><br><span class="line">   pool.shutdown();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line">   <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">    <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + f.get().toString());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">&quot;----程序结束运行----，程序运行时间【&quot;</span></span><br><span class="line">     + (date2.getTime() - date1.getTime()) + <span class="string">&quot;毫秒】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-基于线程池的方式"><a href="#1-4-基于线程池的方式" class="headerlink" title="1.4 基于线程池的方式"></a>1.4 基于线程池的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 提交多个线程任务，并执行</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running ..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-四种线程池"><a href="#2-四种线程池" class="headerlink" title="2.四种线程池"></a>2.四种线程池</h2><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而 只是一个执行线程的工具。真正的线程池接口是 ExecutorService</p><h3 id="2-1-newCachedThreadPool"><a href="#2-1-newCachedThreadPool" class="headerlink" title="2.1 newCachedThreadPool"></a>2.1 newCachedThreadPool</h3><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-newFixedThreadPool"><a href="#2-2-newFixedThreadPool" class="headerlink" title="2.2 newFixedThreadPool"></a>2.2 newFixedThreadPool</h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><h3 id="2-3-newScheduledThreadPool"><a href="#2-3-newScheduledThreadPool" class="headerlink" title="2.3 newScheduledThreadPool"></a>2.3 newScheduledThreadPool</h3><p>创建一个定长线程池，支持定时及周期性任务执行。</p><h3 id="2-4-newSingleThreadExecutor"><a href="#2-4-newSingleThreadExecutor" class="headerlink" title="2.4 newSingleThreadExecutor"></a>2.4 newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><h3 id="核心类-线程池-："><a href="#核心类-线程池-：" class="headerlink" title="核心类(线程池)："></a>核心类(线程池)：</h3><p>四种线程池本质都是创建ThreadPoolExecutor类，ThreadPoolExecutor构造参数如下</p><ol><li>int corePoolSize, 核心线程大小</li><li>int maximumPoolSize,最大线程大小</li><li>long keepAliveTime, 超过corePoolSize的线程多久不活动被销毁时间</li><li>TimeUnit unit,时间单位</li><li>BlockingQueue<Runnable> workQueue 任务队列</li><li>ThreadFactory threadFactory 线程池工厂</li><li>RejectedExecutionHandler handler 拒绝策略</li></ol><h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。 在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞 (Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自 运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><h3 id="3-1-新建状态（New）"><a href="#3-1-新建状态（New）" class="headerlink" title="3.1 新建状态（New）"></a>3.1 新建状态（New）</h3><p><font color="blue">使用new关键字创建了一个线程之后</font>，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。</p><h3 id="3-2-就绪状态（RUNNABLE）"><a href="#3-2-就绪状态（RUNNABLE）" class="headerlink" title="3.2 就绪状态（RUNNABLE）"></a>3.2 就绪状态（RUNNABLE）</h3><p><font color="blue">调用了start()方法之后，</font>该线程就处于就绪状态。JVM会为其创建方法调用栈和程序计数器，等待调度运行</p><h3 id="3-3-运行状态（RUNING）"><a href="#3-3-运行状态（RUNING）" class="headerlink" title="3.3 运行状态（RUNING）"></a>3.3 运行状态（RUNING）</h3><p><font color="blue">就绪状态的线程获得了CPU，开始执行run()方法的线程执行体</font>，该线程就处于处于运行状态</p><h3 id="3-4-阻塞状态（BLOCKED）"><a href="#3-4-阻塞状态（BLOCKED）" class="headerlink" title="3.4 阻塞状态（BLOCKED）"></a>3.4 阻塞状态（BLOCKED）</h3><p>指线程因为某种原因放弃了CPU使用权，暂时停止运行。阻塞状态又分为三种</p><ul><li><p>等待阻塞（o.wait -&gt; 等待队列）</p><ul><li>运行中的线程执行<code>o.wait()</code>方法，JVM会把线程放入等待队列中</li></ul></li><li><p>同步阻塞（lock -&gt; 锁池）</p><ul><li>运行的线程获取对象的同步锁时，若该<font color="blue">同步锁被别的线程占用</font>，则JVM会把该线程放入锁池中</li></ul></li><li><p>其他阻塞（sleep/join）</p><ul><li>运行的线程执行<code>Thread.sleep()</code>或<code>t.join()</code>方法，或者发出I/O请求时，JVM会把该线程设置为阻塞状态。当sleep()状态超时、join()等待线程终止或超市、或者I/O处理完毕，线程重新转入可运行(runnable)状态</li></ul></li></ul><h3 id="3-5-线程死亡（DEAD）"><a href="#3-5-线程死亡（DEAD）" class="headerlink" title="3.5 线程死亡（DEAD）"></a>3.5 线程死亡（DEAD）</h3><p>线程会以下面三种方式结束，结束后就是死亡状态</p><ol><li><p>正常结束</p><p><code>run()</code>或者<code>call()</code>方法执行完成，线程正常结束</p></li><li><p>异常结束</p><p>线程抛出一个未捕获的Exception或Error</p></li><li><p>调用stop</p><p>直接调用线程的<code>stop()</code>方法来结束线程——<font color="blue">容易导致死锁</font>，不推荐使用</p></li></ol><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211212154013983.png" alt="image-20211212154013983"></p><h2 id="4-终止线程4种方式"><a href="#4-终止线程4种方式" class="headerlink" title="4.终止线程4种方式"></a>4.终止线程4种方式</h2><h3 id="4-1-正常运行结束"><a href="#4-1-正常运行结束" class="headerlink" title="4.1 正常运行结束"></a>4.1 正常运行结束</h3><p>程序运行结束，线程自动结束</p><h3 id="4-2-使用退出标志退出程序"><a href="#4-2-使用退出标志退出程序" class="headerlink" title="4.2 使用退出标志退出程序"></a>4.2 使用退出标志退出程序</h3><p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们<font color="blue">需要长时间的 运行，只有在外部某些条件满足的情况下，才能关闭这些线程</font>。使用一个变量来控制循环，例如： 最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while 循环是否退出，代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line"> <span class="comment">//do something</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="blue">使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步</font></p><h3 id="4-3-Interrupt方法结束线程"><a href="#4-3-Interrupt方法结束线程" class="headerlink" title="4.3 Interrupt方法结束线程"></a>4.3 Interrupt方法结束线程</h3><p>使用interrupt()方法来打断线程有两张情况：</p><ol><li><p>线程处于阻塞状态，如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。 阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让 我们有机会结束这个线程的执行。<font color="blue">通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</font></p></li><li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p></li></ol><h3 id="4-4-stop方法终止线程（不安全）"><a href="#4-4-stop方法终止线程（不安全）" class="headerlink" title="4.4 stop方法终止线程（不安全）"></a>4.4 stop方法终止线程（不安全）</h3><p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关 闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子 线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈 现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因 此，并不推荐使用 stop 方法来终止线程。</p><h2 id="5-sleep和wait区别"><a href="#5-sleep和wait区别" class="headerlink" title="5. sleep和wait区别"></a>5. sleep和wait区别</h2><ol><li>原理不同，对于 <code>sleep()</code> 方法，我们首先要知道该方法是属于 Thread 类中的。而 <code>wait()</code> 方法，则是属于 Object 类中的。 </li><li>锁处理机制不同，<code>sleep()</code>最主要作用使线程暂停执行一段时间，时间一到自动恢复，不涉及线程通讯，因此，<font color="blue">调用sleep()方法并不会释放锁。</font></li><li><font color="blue">而当调用wait()方法的时候，线程会释放它所占的锁，进入等待此对象的等待锁定池，</font>只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li><li>使用区域不同，<code>wait()</code>方法必须放在同步代码块或者同步方法中使用，sleep()可以用在任何地方</li></ol><h2 id="6-start和run的区别"><a href="#6-start和run的区别" class="headerlink" title="6. start和run的区别"></a>6. start和run的区别</h2><ol><li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕， 可以直接继续执行下面的代码。 </li><li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 </li><li>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</li></ol><p><font color="red">调用start方法方可启动线程，而run方法只是thread类中的一个普通方法调用，还是在主线程里执行。</font></p><h2 id="7-JAVA后台线程"><a href="#7-JAVA后台线程" class="headerlink" title="7. JAVA后台线程"></a>7. JAVA后台线程</h2><ol><li>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公 共服务，在没有用户线程可服务时会自动离开。 </li><li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</li><li>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在线程对象创建之前用线程对象的 setDaemon 方法。</li><li> 在 Daemon 线程中产生的新线程也是 Daemon 的。 </li><li>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。</li><li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线 程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统 中的可回收资源。</li><li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出</li></ol><h2 id="8-JAVA锁"><a href="#8-JAVA锁" class="headerlink" title="8.  JAVA锁"></a>8.  JAVA锁</h2><h3 id="8-1-乐观锁"><a href="#8-1-乐观锁" class="headerlink" title="8.1 乐观锁"></a>8.1 乐观锁</h3><p>认为读多写少，每次去拿数据的时候都认为别人不会修改，所有不会上锁。但是在更新的时候会判断一下在此期间别人有没有更新这个数据，<font color="blue">策略：当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</font></p><h3 id="8-2-悲观锁"><a href="#8-2-悲观锁" class="headerlink" title="8.2 悲观锁"></a>8.2 悲观锁</h3><p>认为写多，每次去拿数据的时候都任务别人会修改，所有每次读写数据的时候都会上锁。java的悲观锁就是synchronized。</p><h3 id="8-3-自旋锁"><a href="#8-3-自旋锁" class="headerlink" title="8.3 自旋锁"></a>8.3 自旋锁</h3><p>自旋锁原理非常简单，<font color="blue">如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</font></p><p>Synchronized 同步锁</p><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重 入锁。</p><p>作用范围</p><ol><li>作用于方法时，锁住的是对象的实例(this)； </li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁， 会锁所有调用该方法的线程； </li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ol><h3 id="8-4-非公平锁"><a href="#8-4-非公平锁" class="headerlink" title="8.4 非公平锁"></a>8.4 非公平锁</h3><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了 是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非 程序有特殊需要，否则最常用非公平锁的分配机制</p><h3 id="8-5-公平锁"><a href="#8-5-公平锁" class="headerlink" title="8.5 公平锁"></a>8.5 公平锁</h3><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁， ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p><p><strong>ReentrantLock 与 synchronized</strong> </p><ol><li>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出 现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操 作。 </li><li>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要 使用 ReentrantLock。</li></ol><h3 id="8-6-ReadWriteLock-读写锁"><a href="#8-6-ReadWriteLock-读写锁" class="headerlink" title="8.6 ReadWriteLock 读写锁"></a>8.6 ReadWriteLock 读写锁</h3><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><h3 id="8-7-共享锁和独占锁"><a href="#8-7-共享锁和独占锁" class="headerlink" title="8.7 共享锁和独占锁"></a>8.7 共享锁和独占锁</h3><p><strong>独占锁</strong> </p><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p><p><strong>共享锁</strong> </p><p>共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。共享锁则是一种 乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p><ol><li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</li><li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问， 或者被一个写操作访问，但两者不能同时进行</li></ol><h3 id="8-8-可重入锁（递归锁）"><a href="#8-8-可重入锁（递归锁）" class="headerlink" title="8.8 可重入锁（递归锁）"></a>8.8 可重入锁（递归锁）</h3><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock和 synchronized 都是可重入锁</p><h3 id="8-9-偏向锁"><a href="#8-9-偏向锁" class="headerlink" title="8.9 偏向锁"></a>8.9 偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<font color="blue">偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</font>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级 锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，<font color="red">而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令</font>（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。下面说到，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。</p><h3 id="8-10-轻量级锁"><a href="#8-10-轻量级锁" class="headerlink" title="8.10 轻量级锁"></a>8.10 轻量级锁</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</p><p><strong>锁升级</strong> </p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的， 也就是说只能从低到高升级，不会出现锁的降级）。</p><p> “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是， 轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<font color="blue">轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</font></p><h3 id="8-11-重量级锁（Mutex-Lock）"><a href="#8-11-重量级锁（Mutex-Lock）" class="headerlink" title="8.11 重量级锁（Mutex Lock）"></a>8.11 重量级锁（Mutex Lock）</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用 户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，<font color="blue">这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。</font>JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。 JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和 “偏向锁”。</p><h3 id="8-12-锁优化"><a href="#8-12-锁优化" class="headerlink" title="8.12 锁优化"></a>8.12 锁优化</h3><p><strong>减少锁持有时间</strong> </p><ul><li>只用在有线程安全要求的程序上加锁 </li></ul><p><strong>减小锁粒度</strong> </p><ul><li>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是 ConcurrentHashMap。</li></ul><p><strong>锁分离</strong></p><ul><li>用ReadWriteLock将读写的锁分离开来, 尤其在读多写少的场合, 可以有效提升系统的并发能力.</li></ul><p><strong>锁粗化</strong></p><ul><li>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步 和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</li></ul><p><strong>锁消除</strong></p><ul><li>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这 些对象的锁操作，多数是因为程序员编码不规范引起。</li></ul><h2 id="9-线程上下文切换"><a href="#9-线程上下文切换" class="headerlink" title="9. 线程上下文切换"></a>9. 线程上下文切换</h2><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，<font color="blue">任务的状态保存及再加载, 这段过程就叫做上下文切换。</font> 时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</p><p>上下文：是指某一时间点 CPU 寄存器和程序计数器的内容。</p><h3 id="9-1-上下文切换的活动"><a href="#9-1-上下文切换的活动" class="headerlink" title="9.1 上下文切换的活动"></a>9.1 上下文切换的活动</h3><ol><li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。 </li><li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 </li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序 中。</li></ol><h3 id="9-2-引起上下文切换的原因"><a href="#9-2-引起上下文切换的原因" class="headerlink" title="9.2 引起上下文切换的原因"></a>9.2 引起上下文切换的原因</h3><ol><li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； </li><li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务； </li><li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务； </li><li>用户代码挂起当前任务，让出 CPU 时间；</li><li>硬件中断；</li></ol><h2 id="10-线程池原理"><a href="#10-线程池原理" class="headerlink" title="10. 线程池原理"></a>10. 线程池原理</h2><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run  方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 <font color="blue">我们可以继承重写 Thread 类，在其 start 方法中不断添加循环调用传递过来的 Runnable 对象。</font> 这就是线程池的实现原理。<font color="blue">循环方法中不断获取 Runnable 是用 Queue 实现的，</font>在获取下一个 Runnable 之前可以是阻塞的。</p><h3 id="10-1-线程池的组成"><a href="#10-1-线程池的组成" class="headerlink" title="10.1 线程池的组成"></a>10.1 线程池的组成</h3><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度及其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><h3 id="10-2-Java线程池工作过程"><a href="#10-2-Java线程池工作过程" class="headerlink" title="10.2 Java线程池工作过程"></a>10.2 Java线程池工作过程</h3><ol><li><p>在创建线程后，等待提交过来的任务请求。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断： </p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； </p></li><li><p> 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p></li><li><p>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p></li><li><p>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </p></li></ul></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211213111248803.png" alt="image-20211213111248803"></p></li></ol><h3 id="10-3-拒绝策略"><a href="#10-3-拒绝策略" class="headerlink" title="10.3 拒绝策略"></a>10.3 拒绝策略</h3><ol><li>AbortPolicy：直接抛出异常，阻止系统正常运行。 </li><li>CallerRunsPolicy：”调用者运行”一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是返回给调用者进行处理</li><li>DiscardOldestPolicy：将最早进入队列的任务删除,之后再尝试加入队列。</li><li>DiscardPolicy ：直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略。</li></ol><p>若以上策略仍无法满足实际 需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p><h3 id="10-4-为什么使用线程池，它的优势"><a href="#10-4-为什么使用线程池，它的优势" class="headerlink" title="10.4 为什么使用线程池，它的优势"></a>10.4 为什么使用线程池，它的优势</h3><ol><li>线程池做的工作主要是控制运行的线程的数量,处理过程中将任务加入队列,然后在线程创建后启动这些任务,如果显示超过了最大数量,超出的数量的线程排队等候,等其他线程执行完毕,再从队列中取出任务来执行.</li><li>它的主要特点为:线程复用 | 控制最大并发数 | 管理线程.</li></ol><h2 id="11-volatile关键字作用"><a href="#11-volatile关键字作用" class="headerlink" title="11. volatile关键字作用"></a>11. volatile关键字作用</h2><ul><li><p>变量可见性 </p><p>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的 值对于其他线程是可以立即获取的。 </p></li><li><p>禁止重排序 </p><p>volatile 禁止了指令重排。</p></li></ul><h2 id="12-synchronized-和-ReentrantLock-的区别"><a href="#12-synchronized-和-ReentrantLock-的区别" class="headerlink" title="12. synchronized 和 ReentrantLock 的区别"></a>12. synchronized 和 ReentrantLock 的区别</h2><p>共同点</p><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁 </li><li>都保证了可见性和互斥性</li></ol><p>不同点</p><ol><li>ReentrantLock 显式的获得、释放锁，synchronized 隐式获得释放锁 </li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 </li><li>ReentrantLock 可以实现公平锁 </li><li>ReentrantLock 通过 Condition 可以绑定多个条件 </li><li>底层实现不一样， <font color="blue">synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</font></li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言 实现。 </li><li><font color="blue">synchronized 在发生异常时，会自动释放线程占有的锁，</font>因此不会导致死锁现象发生； 而 tLock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象， 因此使用 Lock 时需要在 finally 块中释放锁。 </li><li><font color="blue">Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，</font>使用 synchronized 时， 等待的线程会一直等待下去，不能够响应中断。 </li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 </li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol><h2 id="13-阻塞队列原理"><a href="#13-阻塞队列原理" class="headerlink" title="13. 阻塞队列原理"></a>13. 阻塞队列原理</h2><h3 id="13-1-原理"><a href="#13-1-原理" class="headerlink" title="13.1 原理"></a>13.1 原理</h3><ol><li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放 入队列。</p><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211213111848362.png" alt="image-20211213111848362"></p></li><li><p>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有 空的位置，线程被自动唤醒。</p></li></ol><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211213111856572.png" alt="image-20211213111856572"></p><p>DelayQueue、ArrayBlockingQueue、LinkedBlockingQueue</p><h3 id="13-2-Java中的阻塞队列"><a href="#13-2-Java中的阻塞队列" class="headerlink" title="13.2 Java中的阻塞队列"></a>13.2 Java中的阻塞队列</h3><ol><li>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 </li><li>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 </li><li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 </li><li>DelayQueue：使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：不存储元素的阻塞队列。 </li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ol><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211213112137512.png" alt="image-20211213112137512"></p><h3 id="13-3-ArrayBlockingQueue-公平、非公平"><a href="#13-3-ArrayBlockingQueue-公平、非公平" class="headerlink" title="13.3 ArrayBlockingQueue(公平、非公平)"></a>13.3 ArrayBlockingQueue(公平、非公平)</h3><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。<font color="blue">默认情况下不保证访问者公平的访问队列，</font>所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。</p><h3 id="13-4-LinkedBlockingQueue（两个独立锁提高并发）"><a href="#13-4-LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="13.4 LinkedBlockingQueue（两个独立锁提高并发）"></a>13.4 LinkedBlockingQueue（两个独立锁提高并发）</h3><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。<font color="blue">而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，</font>这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h3 id="13-5-DelayQueue（缓存失效、定时任务-）"><a href="#13-5-DelayQueue（缓存失效、定时任务-）" class="headerlink" title="13.5 DelayQueue（缓存失效、定时任务 ）"></a>13.5 DelayQueue（缓存失效、定时任务 ）</h3><p>是一个<font color="blue">支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。</font>队列中的元素必须实 现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才 能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景： </p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。 </li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ol><h2 id="14-ThreadLocal"><a href="#14-ThreadLocal" class="headerlink" title="14. ThreadLocal"></a>14. ThreadLocal</h2><p>ThreadLocal 的作用是提供线程内的局部变量，<font color="blue">这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</font>ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Java线程实现-创建方式&quot;&gt;&lt;a href=&quot;#1-Java线程实现-创建方式&quot; class=&quot;headerlink&quot; title=&quot;1.Java线程实现/创建方式&quot;&gt;&lt;/a&gt;1.Java线程实现/创建方式&lt;/h2&gt;&lt;h3 id=&quot;1-1-继承Thread类</summary>
      
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="面试题" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="面试" scheme="https://zhongnf.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ面试题</title>
    <link href="https://zhongnf.github.io/2021/12/11/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhongnf.github.io/2021/12/11/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-12-11T09:23:13.000Z</published>
    <updated>2021-12-11T09:34:13.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RabbitMQ-是什么？"><a href="#1-RabbitMQ-是什么？" class="headerlink" title="1.RabbitMQ 是什么？"></a>1.RabbitMQ 是什么？</h2><p>RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p><p>PS: 也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p><h2 id="2-RabbitMQ-特点？"><a href="#2-RabbitMQ-特点？" class="headerlink" title="2.RabbitMQ 特点？"></a>2.RabbitMQ 特点？</h2><ol><li>可靠性: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li><li>灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li><li>扩展性: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li><li>高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li><li>多种协议: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li><li>多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li><li>管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li><li>插件机制 : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li></ol><h2 id="3-AMQP-是什么？"><a href="#3-AMQP-是什么？" class="headerlink" title="3.AMQP 是什么？"></a>3.AMQP 是什么？</h2><p>RabbitMQ 就是 AMQP 协议的 Erlang 的实现 (当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p><p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p><h2 id="4-AMQP-协议-3-层？"><a href="#4-AMQP-协议-3-层？" class="headerlink" title="4.AMQP 协议 3 层？"></a>4.AMQP 协议 3 层？</h2><ul><li><p>Module Layer: 协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</p></li><li><p>Session Layer: 中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</p></li></ul><ul><li>TransportLayer: 最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li></ul><h2 id="5-AMQP-模型的几大组件？"><a href="#5-AMQP-模型的几大组件？" class="headerlink" title="5.AMQP 模型的几大组件？"></a>5.AMQP 模型的几大组件？</h2><ul><li>交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。</li><li>队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。</li><li>绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。</li></ul><h2 id="6-说说生产者-Producer-和消费者-Consumer"><a href="#6-说说生产者-Producer-和消费者-Consumer" class="headerlink" title="6.说说生产者 Producer 和消费者 Consumer?"></a>6.说说生产者 Producer 和消费者 Consumer?</h2><p>生产者</p><ul><li><p>消息生产者，就是投递消息的一方。</p></li><li><p>消息一般包含两个部分：消息体（payload) 和标签 (Label)。</p></li></ul><p>消费者</p><ul><li><p>消费消息，也就是接收消息的一方。</p></li><li><p>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</p></li></ul><h2 id="7-为什么需要消息队列？"><a href="#7-为什么需要消息队列？" class="headerlink" title="7.为什么需要消息队列？"></a>7.为什么需要消息队列？</h2><p>从本质上来说是因为互联网的快速发展，业务不断扩张，促使技术架构需要不断的演进。</p><p>从以前的单体架构到现在的微服务架构，成百上千的服务之间相互调用和依赖。从互联网初期一个服务器上有 100 个在线用户已经很了不得，到现在坐拥 10 亿日活的微信。此时，我们需要有一个「工具」来解耦服务之间的关系、控制资源合理合时的使用以及缓冲流量洪峰等等。因此，消息队列就应运而生了。</p><p>它常用来实现：异步处理、服务解耦、流量控制（削峰）。</p><h2 id="8-说说-Broker-服务节点、Queue-队列、Exchange-交换器？"><a href="#8-说说-Broker-服务节点、Queue-队列、Exchange-交换器？" class="headerlink" title="8.说说 Broker 服务节点、Queue 队列、Exchange 交换器？"></a>8.说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2><ul><li>Broker 可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li><li>Queue:RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li><li>Exchange: 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li></ul><h2 id="9-消息队列有什么优缺点"><a href="#9-消息队列有什么优缺点" class="headerlink" title="9.消息队列有什么优缺点"></a>9.消息队列有什么优缺点</h2><p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：</p><ul><li><p>系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩 溃，你不就完了？</p></li><li><p>系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？</p></li><li><p>怎么保证消息传递的顺序性？问题一大堆。</p></li><li><p>一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致 了。</p></li></ul><h2 id="10-如何保证消息的可靠性？"><a href="#10-如何保证消息的可靠性？" class="headerlink" title="10.如何保证消息的可靠性？"></a>10.如何保证消息的可靠性？</h2><p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p><p>生产者到RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p><p>RabbitMQ自身：持久化、集群、普通模式、镜像模式。</p><p>RabbitMQ到消费者：basicAck 机制、死信队列、消息补偿机制。</p><h2 id="11-什么是-RoutingKey-路由键？"><a href="#11-什么是-RoutingKey-路由键？" class="headerlink" title="11.什么是 RoutingKey 路由键？"></a>11.什么是 RoutingKey 路由键？</h2><p>生产者将消息发送给交换器的时候，会指定一个 RoutingKey, 用来指定这个消息的路由规则，这个 RoutingKey 需要与交换器类型和绑定键 (BindingKey) 联合使用才能最终生效。</p><h2 id="12-Binding-绑定？"><a href="#12-Binding-绑定？" class="headerlink" title="12.Binding 绑定？"></a>12.Binding 绑定？</h2><p>通过绑定将交换器和队列关联起来，一般会指定一个 BindingKey, 这样 RabbitMq 就知道如何正确路由消息到队列了。</p><h2 id="13-交换器-4-种类型？"><a href="#13-交换器-4-种类型？" class="headerlink" title="13.交换器 4 种类型？"></a>13.交换器 4 种类型？</h2><p>主要有以下 4 种。</p><ul><li><p>fanout: 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</p></li><li><p>direct: 把消息路由到 BindingKey 和 RoutingKey 完全匹配的队列中。</p></li><li><p>topic:</p></li></ul><p>匹配规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RoutingKey` 为一个 点号<span class="string">&#x27;.&#x27;</span>: 分隔的字符串。比如: `java.xiaoka.show</span><br></pre></td></tr></table></figure><p>BindingKey 和 RoutingKey 一样也是点号 “.“分隔的字符串。</p><p>BindingKey 可使用 * 和 # 用于做模糊匹配，* 匹配一个单词，# 匹配多个或者 0 个</p><p>headers: 不依赖路由键匹配规则路由消息。是根据发送消息内容中的 headers 属性进行匹配。性能差，基本用不到。</p><h2 id="14-生产者消息运转？"><a href="#14-生产者消息运转？" class="headerlink" title="14.生产者消息运转？"></a>14.生产者消息运转？</h2><ul><li><p>Producer 先连接到 Broker, 建立连接 Connection, 开启一个信道 (Channel)。</p></li><li><p>Producer 声明一个交换器并设置好相关属性。</p></li></ul><ul><li>Producer 声明一个队列并设置好相关属性。</li></ul><ul><li>Producer 通过路由键将交换器和队列绑定起来。</li></ul><ul><li>Producer 发送消息到 Broker, 其中包含路由键、交换器等信息。</li></ul><ul><li>相应的交换器根据接收到的路由键查找匹配的队列。</li></ul><ul><li>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</li></ul><ul><li>关闭信道。</li></ul><ul><li>管理连接。</li></ul><h2 id="消费者接收消息15-过程？"><a href="#消费者接收消息15-过程？" class="headerlink" title="消费者接收消息15.过程？"></a>消费者接收消息15.过程？</h2><ul><li><p>Producer 先连接到 Broker, 建立连接 Connection, 开启一个信道 (Channel)。</p></li><li><p>向 Broker 请求消费响应的队列中消息，可能会设置响应的回调函数。</p></li></ul><ul><li>等待 Broker 回应并投递相应队列中的消息，接收消息。</li></ul><ul><li>消费者确认收到的消息，ack。</li></ul><ul><li>RabbitMq 从队列中删除已经确定的消息。</li></ul><ul><li>关闭信道。</li></ul><ul><li>关闭连接。</li></ul><h2 id="16-交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"><a href="#16-交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？" class="headerlink" title="16.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"></a>16.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？</h2><ul><li>mandatory ：true 返回消息给生产者。</li><li>mandatory: false 直接丢弃。</li></ul><h2 id="17-死信队列？"><a href="#17-死信队列？" class="headerlink" title="17.死信队列？"></a>17.死信队列？</h2><p>DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p><h2 id="18-导致的死信的几种原因？"><a href="#18-导致的死信的几种原因？" class="headerlink" title="18.导致的死信的几种原因？"></a>18.导致的死信的几种原因？</h2><ul><li>消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。</li><li>消息 TTL 过期。</li><li>队列满了，无法再添加。</li></ul><h2 id="18-延迟队列？"><a href="#18-延迟队列？" class="headerlink" title="18.延迟队列？"></a>18.延迟队列？</h2><p>存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p><h2 id="19-优先级队列？"><a href="#19-优先级队列？" class="headerlink" title="19.优先级队列？"></a>19.优先级队列？</h2><ul><li>优先级高的队列会先被消费。</li><li>可以通过 x-max-priority 参数来实现。</li><li>当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</li></ul><h2 id="20-事务机制？"><a href="#20-事务机制？" class="headerlink" title="20.事务机制？"></a>20.事务机制？</h2><p>RabbitMQ 客户端中与事务机制相关的方法有三个:</p><p>channel.txSelect 用于将当前的信道设置成事务模式。</p><p>channel . txCommit 用于提交事务 。</p><p>channel . txRollback 用于事务回滚，如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，通过 txRollback 来回滚。</p><h2 id="21-发送确认机制？"><a href="#21-发送确认机制？" class="headerlink" title="21.发送确认机制？"></a>21.发送确认机制？</h2><p>生产者把信道设置为 confirm 确认模式，设置后，所有再改信道发布的消息都会被指定一个唯一的 ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（Basic.Ack) 给生产者（包含消息的唯一 ID)，这样生产者就知道消息到达对应的目的地了。</p><h2 id="消费22-者获取消息的方式？"><a href="#消费22-者获取消息的方式？" class="headerlink" title="消费22.者获取消息的方式？"></a>消费22.者获取消息的方式？</h2><ul><li>推</li><li>拉</li></ul><h2 id="23-消费者某些原因无法处理当前接受的消息如何来拒绝？"><a href="#23-消费者某些原因无法处理当前接受的消息如何来拒绝？" class="headerlink" title="23.消费者某些原因无法处理当前接受的消息如何来拒绝？"></a>23.消费者某些原因无法处理当前接受的消息如何来拒绝？</h2><p>channel .basicNack channel .basicReject</p><h2 id="24-消息传输保证层级？"><a href="#24-消息传输保证层级？" class="headerlink" title="24.消息传输保证层级？"></a>24.消息传输保证层级？</h2><ul><li><p>At most once: 最多一次。消息可能会丢失，但不会重复传输。</p></li><li><p>At least once：最少一次。消息绝不会丢失，但可能会重复传输。</p></li></ul><ul><li>Exactly once: 恰好一次，每条消息肯定仅传输一次。</li></ul><h2 id="25-了解-Virtual-Host-吗？"><a href="#25-了解-Virtual-Host-吗？" class="headerlink" title="25.了解 Virtual Host 吗？"></a>25.了解 Virtual Host 吗？</h2><p>每一个 RabbitMQ 服务器都能创建虚拟的消息服务器，也叫虚拟主机 (virtual host)，简称 vhost。默认为 “/”。</p><h2 id="集26-群中的节点类型？"><a href="#集26-群中的节点类型？" class="headerlink" title="集26.群中的节点类型？"></a>集26.群中的节点类型？</h2><ul><li><p>内存节点：ram, 将变更写入内存。</p></li><li><p>磁盘节点：disc, 磁盘写入操作。</p></li></ul><ul><li>RabbitMQ 要求最少有一个磁盘节点。</li></ul><h2 id="27-队列结构？"><a href="#27-队列结构？" class="headerlink" title="27.队列结构？"></a>27.队列结构？</h2><p>通常由以下两部分组成？</p><ul><li>rabbit_amqqueue_process: 负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认 (包括生产端的 confirm 和消费端的 ack) 等。</li></ul><ul><li>backing_queue: 是消息存储的具体形式和引擎，并向 rabbit amqqueue process 提供相关的接口以供调用。</li></ul><h2 id="28-RabbitMQ-中消息可能有的几种状态？"><a href="#28-RabbitMQ-中消息可能有的几种状态？" class="headerlink" title="28.RabbitMQ 中消息可能有的几种状态？"></a>28.RabbitMQ 中消息可能有的几种状态？</h2><ul><li><p>alpha: 消息内容 (包括消息体、属性和 headers) 和消息索引都存储在内存中 。</p></li><li><p>beta: 消息内容保存在磁盘中，消息索引保存在内存中。</p></li></ul><ul><li>gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。</li></ul><ul><li>delta: 消息内容和索引都在磁盘中 。</li></ul><h2 id="29-在何种场景下使用了消息中间件？"><a href="#29-在何种场景下使用了消息中间件？" class="headerlink" title="29.在何种场景下使用了消息中间件？"></a>29.在何种场景下使用了消息中间件？</h2><ul><li>接口之间耦合比较严重</li><li>面对大流量并发时，容易被冲垮</li><li>存在性能问题</li></ul><h2 id="30-生产者如何将消息可靠投递到-MQ？"><a href="#30-生产者如何将消息可靠投递到-MQ？" class="headerlink" title="30.生产者如何将消息可靠投递到 MQ？"></a>30.生产者如何将消息可靠投递到 MQ？</h2><ol><li><p>Client 发送消息给 MQ；</p></li><li><p>MQ 将消息持久化后，发送 Ack 消息给 Client，此处有可能因为网络问题导致 Ack 消息无法发送到 Client，那么 Client 在等待超时后，会重传消息；</p></li><li><p>Client 收到 Ack 消息后，认为消息已经投递成功。</p></li></ol><h2 id="31-MQ-如何将消息可靠投递到消费者？"><a href="#31-MQ-如何将消息可靠投递到消费者？" class="headerlink" title="31.MQ 如何将消息可靠投递到消费者？"></a>31.MQ 如何将消息可靠投递到消费者？</h2><ol><li><p>MQ 将消息 push 给 Client（或 Client 来 pull 消息）</p></li><li><p>Client 得到消息并做完业务逻辑</p></li><li><p>Client 发送 Ack 消息给 MQ，通知 MQ 删除该消息，此处有可能因为网络问题导致 Ack 失败，那么 Client 会重复消息，这里就引出消费幂等的问题；</p></li><li><p>MQ 将已消费的消息删除</p></li></ol><h2 id="32-如何保证-RabbitMQ-消息队列的高可用？"><a href="#32-如何保证-RabbitMQ-消息队列的高可用？" class="headerlink" title="32.如何保证 RabbitMQ 消息队列的高可用？"></a>32.如何保证 RabbitMQ 消息队列的高可用？</h2><p>RabbitMQ 有三种模式：单机模式，普通集群模式，镜像集群模式。</p><ol><li>单机模式：就是 demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ol><ol start="2"><li><p>普通集群模式：意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。</p></li><li><p>镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式，跟普通集群模式不一样的是，你创建的 queue，无论元数据 (元数据指 RabbitMQ 的配置数据) 还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-RabbitMQ-是什么？&quot;&gt;&lt;a href=&quot;#1-RabbitMQ-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.RabbitMQ 是什么？&quot;&gt;&lt;/a&gt;1.RabbitMQ 是什么？&lt;/h2&gt;&lt;p&gt;RabbitMQ 是实现了高级消息队</summary>
      
    
    
    
    <category term="rabbitmq" scheme="https://zhongnf.github.io/categories/rabbitmq/"/>
    
    
    <category term="面试" scheme="https://zhongnf.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="rabbitmq" scheme="https://zhongnf.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Redis面试题</title>
    <link href="https://zhongnf.github.io/2021/12/11/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhongnf.github.io/2021/12/11/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-12-11T09:02:24.000Z</published>
    <updated>2021-12-11T09:19:54.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-说说什么是-Redis"><a href="#1-说说什么是-Redis" class="headerlink" title="1.说说什么是 Redis?"></a>1.说说什么是 Redis?</h3><blockquote><p>Redis 是一个开源（BSD 许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，HyperLogLogs 等数据类型。内置复制、Lua 脚本、LRU 收回、事务，以及不同级别磁盘持久化功能，同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。根据月度排行网站 DB-Engines 的数据，Redis 是最流行的键值对存储数据库。</p></blockquote><p>Redis 全称为：Remote Dictionary Server（远程数据服务），是一个基于内存且支持持久化的高性能 key-value 数据库。具备以下三个基本特征：</p><ul><li><p>多数据类型</p></li><li><p>持久化机制</p></li><li><p>主从同步</p></li></ul><h2 id="2-Redis的数据类型有哪些"><a href="#2-Redis的数据类型有哪些" class="headerlink" title="2.Redis的数据类型有哪些"></a>2.Redis的数据类型有哪些</h2><p>Redis 主要有以下几种数据类型：</p><ul><li><p>String：这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</p></li><li><p>Hash：这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。</p></li><li><p>List：List 是有序列表，这个可以玩儿出很多花样。比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p></li><li><p>Sets：是无序集合，自动去重。直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 Redis 进行全局的 set 去重。</p></li><li><p>Sorted Set：排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。可以用来做排行榜相关功能。</p></li></ul><h2 id="3-Redis是单线程吗"><a href="#3-Redis是单线程吗" class="headerlink" title="3.Redis是单线程吗"></a>3.Redis是单线程吗</h2><p>这里的单线程指的是 Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><h2 id="4-Redis-为什么设计成单线程的？"><a href="#4-Redis-为什么设计成单线程的？" class="headerlink" title="4.Redis 为什么设计成单线程的？"></a>4.Redis 为什么设计成单线程的？</h2><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程，避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO，内部采用 epoll，epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，避免 IO 代价。</li></ol><h2 id="6-Redis-和-Memcached-的区别有哪些？"><a href="#6-Redis-和-Memcached-的区别有哪些？" class="headerlink" title="6.Redis 和 Memcached 的区别有哪些？"></a>6.Redis 和 Memcached 的区别有哪些？</h2><p>从以下 8 个方面来讲：</p><ul><li><p>Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。不过 Memcache 还可用于缓存其他东西，例如图片、视频等等。</p></li><li><p>Memcache 仅支持 key-value 结构的数据类型，Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，hash 等数据结构的存储。</p></li><li><p>虚拟内存– Redis 当物理内存用完时，可以将一些很久没用到的 value 交换到磁盘；分布式–设定 Memcache 集群，利用 magent 做一主多从；Redis 可以做一主多从。都可以一主一从</p></li><li><p>存储数据安全– Memcache 挂掉后，数据没了；Redis 可以定期保存到磁盘（持久化）</p></li><li><p>Memcache 的单个 value 最大 1m ， Redis 的单个 value 最大 512m 。</p></li><li><p>灾难恢复– Memcache 挂掉后，数据不可恢复；Redis 数据丢失后可以通过 aof 恢复</p></li><li><p>Redis 原生就支持集群模式， Redis3.0 版本中，官方便能支持 Cluster 模式了， Memcached 没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。</p></li><li><p>Memcached 网络 IO 模型是多线程，非阻塞 IO 复用的网络模型，原型上接近于 nignx 。而 Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现类 epoll，kqueue 和 select ，更接近于 Apache 早期的模式。</p></li></ul><h2 id="7-Redis为什么采用跳表而不是红黑树？"><a href="#7-Redis为什么采用跳表而不是红黑树？" class="headerlink" title="7.Redis为什么采用跳表而不是红黑树？"></a>7.Redis为什么采用跳表而不是红黑树？</h2><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。<br>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。<br>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h2 id="7-什么是跳表"><a href="#7-什么是跳表" class="headerlink" title="7.什么是跳表"></a>7.什么是跳表</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-说说什么是-Redis&quot;&gt;&lt;a href=&quot;#1-说说什么是-Redis&quot; class=&quot;headerlink&quot; title=&quot;1.说说什么是 Redis?&quot;&gt;&lt;/a&gt;1.说说什么是 Redis?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 是一个开源</summary>
      
    
    
    
    <category term="redis" scheme="https://zhongnf.github.io/categories/redis/"/>
    
    
    <category term="面试" scheme="https://zhongnf.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="redis" scheme="https://zhongnf.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之JUC.ConcurrentHashMap源码解读</title>
    <link href="https://zhongnf.github.io/2021/12/11/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhongnf.github.io/2021/12/11/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-11T07:36:30.000Z</published>
    <updated>2021-12-13T06:32:45.332Z</updated>
    
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="AQS" scheme="https://zhongnf.github.io/tags/AQS/"/>
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码" scheme="https://zhongnf.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="ConcurrentHashMap" scheme="https://zhongnf.github.io/tags/ConcurrentHashMap/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之JUC.CountDownLatch源码解读</title>
    <link href="https://zhongnf.github.io/2021/12/11/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhongnf.github.io/2021/12/11/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-11T07:32:30.000Z</published>
    <updated>2021-12-13T06:32:55.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>​    CountDownLatch基于AQS，实现了门栓，在开发中可以将其用作任务计数器。CountDownLatch是比较典型的AQS共享模式的使用。</p><p>​    CountDownLatch这种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作执行完成。</p><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211211145945014.png" alt="image-20211211145945014"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>比如我们打王者荣耀，在游戏正式开始前需要匹配到对应的玩家数，并且玩家加载完成才能开始游戏。看到这个例子大家可能想，不对呀，当有某人玩家加载时间过长（退出游戏界面了，网络不好等原因），其他正常加载的人进入了游戏界面，开始游戏。</p><p>这是因为在某些情况下，某个子任务耗时过程，甚至可能内部已经出现异常，主线程如果无休止地等待下去可能会导致主线程长时间阻塞，表现为假死。</p><p>针对这一个问题，可以对CountDownLatch设置超时时间。一旦主线程等待超时，那么就直接被唤醒，继续执行后续逻辑。这就是为什么有某个玩家加载时间过长，其他用户能直接开始游戏的原因。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>其内部只有一个Sync的成员属性，相信看了前面的分析，对这个内部类是很熟悉的。</p><p>CountDownLatch的唯一构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count代表子任务个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类Sync"><a href="#内部类Sync" class="headerlink" title="内部类Sync"></a>内部类Sync</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前需要等待的任务数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当state为0，代表子任务全部完成，返回1,否则返回-1</span></span><br><span class="line">        <span class="comment">// 返回-1代表尝试获取锁失败，有需要的话会入队等待</span></span><br><span class="line">        <span class="comment">// 返回1表示获取锁成功，并唤醒后续结点（如果它也在等待共享锁）</span></span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// state 等于0，说明子任务已经完成，不需要释放锁，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 否则，通过CAS自减1，直到state为0，说明锁已经被完全释放，返回true</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。</p></blockquote><p>这里我们先简单的介绍下AQS的共享模式。主要从两个方面去理解：</p><ol><li>state</li></ol><p>​    独占模式下，当state为1，代表锁正在被占用，其他想要获取锁的线程必须等待。共享模式下，state的值可以    被多个线程同时修改，增加1代表当前线程获取共享锁，减去1代表当前线程释放锁。</p><ol start="2"><li>FIFO队列</li></ol><p>​    独占模式下，只有即将出队的Node中的线程被唤醒。共享模式下，除了即将出队的Node中的线程被唤醒，也    会唤醒后续处于共享模式下Node中的线程</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>对于CountDownLatch，我们仅仅需要关心两个方法，<code>countDown()</code>和 <code>await()</code>方法。</p><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>先看<code>void await()</code>方法</p><p>它代表线程阻塞，等待state的值减为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主线程调用await时，实际上调用的是AQS内部的<code>acquireSharedInterruptibly</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 先判断tryAcquireShared(arg)返回值，为负数再执行doAcquireSharedInterruptibly(arg)</span></span><br><span class="line">    <span class="comment">// tryAcquireShared上面已经解释过，返回-1代表尝试获取锁失败，有需要的话会入队等待</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对此的理解是：如果子任务已经全部完成了，那么await直接返回。否则调用doAcquireSharedInterruptibly方法，而doAcquireSharedInterruptibly的作用主要是初始化一个主线程的Node结点，该结点进入AQS的FIFO队列，并等待子任务全部完成。</p><p>接下来看下doAcquireSharedInterruptibly方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 入队</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 大于0表示子任务全部完成，此时方法返回，await的主线程也将会返回</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h5><p>接下来看<code>void countDown()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用AQS的<code>releaseShared</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果tryReleaseShared(arg)返回true，调用doReleaseShared</span></span><br><span class="line">    <span class="comment">// 即当前任务完成了就唤醒FIFO队列中正在等待的Node，也就是主线程结点。</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;​    CountDownLatch基于A</summary>
      
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="AQS" scheme="https://zhongnf.github.io/tags/AQS/"/>
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码" scheme="https://zhongnf.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    <category term="CountDownLatch" scheme="https://zhongnf.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之JUC.ReentrantLock源码解读</title>
    <link href="https://zhongnf.github.io/2021/12/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhongnf.github.io/2021/12/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8BJUC.ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-10T12:29:30.000Z</published>
    <updated>2021-12-13T06:33:04.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文阅读前，需要先了解AQS的基本知识。如果你还不了解AQS，请先阅读上一篇文章<a href="https://zhongnf.github.io/2021/12/09/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9AAQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">《Java并发之AbstractQueuedSynchronizer源码解读》</a></p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 基于 AQS，实现了公平锁和非公平锁，在开发中可以用它对资源进行同步。</p><p>对于ReentrantLock类的源码主要关注以下几点：</p><ul><li><p>属性：sync</p></li><li><p>内部类Sync、NonfairSync、FairSync</p></li><li><p>方法</p><ul><li>继承实现方法：</li><li>私有方法</li></ul></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>sync是ReentranLock的唯一属性，一旦初始化就不能修改引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续会详细讲解公平锁和非公平锁。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平尝试获取锁 重点关注</span></span><br><span class="line">    <span class="comment">//为什么会放在Sync中实现内，而不是放在NonFairSync中实现，后面讲</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是否为获得锁的独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于当前Lock对象创建的一个Condition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取正在占用锁的那个线程对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取state的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判断锁是否空闲</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于反序列化，很少使用可忽略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看一下nonfairTryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法逻辑比较简单：</p><ol><li>获取state，AQS维护不了解请看上一篇文章介绍</li><li>当state为0，代表锁空闲，便可以通过cas来改变state，如果改变成功说明获取了锁，将当前线程设置为独占线程，并返回true。</li><li>当state不为0，判断当前线程是否已经是独占线程（已经获得了锁），如果是重入，重入次数+1，返回true。代码中为什么要判断nextc是否小于0呢（<code>if (nextc &lt; 0)</code>）？是因为nextc是int型，其为16位，可能溢出变成负数。</li><li>否则尝试获取锁失败。</li></ol><p>接下来看 <code>tryRealease</code>方法：释放锁是一个通用操作，故而放在Sync类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经介绍完了Sync类。它的两个子类NonfairSync、FairSync分别实现了公平锁和非公平锁。</p><p>何为公平锁和非公平锁？</p><ul><li><p>公平锁：锁的分配按照请求获取锁的顺序</p></li><li><p>非公平锁：锁的分配不按照请求的顺序，是抢占式的。</p></li></ul><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p>NonfairSync重写了Sync中的<code>lock</code> 和<code>tryAcquire</code>两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先尝试通过CAS获取锁，失败怎调用AQS提供的acquire</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接调用AQS的acquire</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 得知锁没有被线程占有后，先判断有没有线程已经在队列中等待，然后再尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从二者重写的方法中不难看出，非公平锁总是会先CAS尝试下获取锁，失败后再进入公平锁一样的逻辑</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>直接调用了sync对象实现的方法，此方法已经分别在NonfairSync 和 FairSync中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lockInterruptibly</code>和<code>lock</code>方法的区别在于，当线程等待锁的期间，是否立即相应中断。<code>lock</code>方法中，线程会在等待获取锁之后，再响应中断。<code>lockInterruptibly</code>方法中，若线程在等待获取锁期间被调用了中断，那么将立即抛出中断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以解释上面的<code>nonfairTryAcquire</code>为什么在Sync类中直接实现，而不是在非公平类中实现。无论ReentrantLock被指定为公平锁还是非公平锁，<code>tryLock</code> 操作都是不公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>后续补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文阅读前，需要先了解AQS的基本知识。如果你还不了解AQS，请先阅读上一篇文章&lt;a href=&quot;https://zhongnf.github.io/2021/12/09/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9AAQ</summary>
      
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="AQS" scheme="https://zhongnf.github.io/tags/AQS/"/>
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码" scheme="https://zhongnf.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AbstractQueuedSynchronizer源码解读</title>
    <link href="https://zhongnf.github.io/2021/12/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9AAQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://zhongnf.github.io/2021/12/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9AAQS%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-12-10T07:33:30.000Z</published>
    <updated>2021-12-13T07:58:55.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS是JUC的核心组件，AQS引入了独占锁、共享锁等性质。首先，先来看看AQS的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><p><img src="https://gitee.com/zhong-niangfu/typora-img/raw/master/img/image-20211209155102644.png" alt="image-20211209155102644"></p><p>其中队列中的每一个结点类型都是一个内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">   <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下面几个变量是waitStatus的状态变化值 **/</span></span><br><span class="line">    <span class="comment">// 代表此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 代表当前的node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表当前节点正在等待某个Condition对象，和条件模式相关，暂时不介绍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 传共享模式下锁释放状态，和共享模式有关，暂时不介绍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 大于 0 代表此线程取消了等待</span></span><br><span class="line">    <span class="comment">// 0表示其初始值或节点已经释放锁</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node主要存储了线程对象（thread）、节点在队列里的等待状态（waitStatus）、前后指针（pre、next）等信息。其中需要重点关注waitStatus属性，AQS的变化伴随着waitStatus值的变化。</p><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>接下来我们看线程抢锁的操作。</p><p>这是AQS中的两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire是一个被<code>protected</code>修饰的方法，参数int，代表对Int state的增加操作，返回boolean，代表是否成功获取锁。由子类重写此方法，否则抛出异常。</p><p>接下来我们看 ReentrantLock 中 FairSync 部分的具体实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="comment">// 争锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*******来自父类AQS，调用父类AQS的 acquire 方法 *******/</span></span><br><span class="line">    <span class="comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line">    <span class="comment">// 否则，acquireQueued方法会将线程压到队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时 arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span></span><br><span class="line">        <span class="comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span></span><br><span class="line">        <span class="comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">    <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 更新state的值</span></span><br><span class="line">            setState(nextc); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">        <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">        <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">        <span class="comment">//     selfInterrupt();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span></span><br><span class="line">      <span class="comment">//        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span></span><br><span class="line">    <span class="comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span></span><br><span class="line">    <span class="comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class="line">        Node pred = tail; <span class="comment">// tail不要忘了，AQS的属性之一，阻塞的尾节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 将当前的队尾节点，设置为自己的前驱 </span></span><br><span class="line">            node.prev = pred; </span><br><span class="line">            <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                <span class="comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class="line">                <span class="comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class="line">        <span class="comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">        <span class="comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 采用自旋的方式入队</span></span><br><span class="line">    <span class="comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class="line">    <span class="comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 之前说过，队列为空也会进来这里</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 初始化head节点</span></span><br><span class="line">                <span class="comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span></span><br><span class="line">                <span class="comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    <span class="comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class="line">                    <span class="comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class="line">                    <span class="comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class="line">                    <span class="comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class="line">                <span class="comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，又回到这段代码了</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class="line">                <span class="comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class="line">                <span class="comment">// 所以当前节点可以去试抢一下锁</span></span><br><span class="line">                <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">                <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">                <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">                <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">                <span class="comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">                <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">//返回false回继续循环</span></span><br><span class="line">                    <span class="comment">//挂起线程</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 什么时候 failed 会为 true???</span></span><br><span class="line">            <span class="comment">// tryAcquire() 方法抛异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span></span><br><span class="line">    <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">        <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">        <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">        <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">        <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">        <span class="comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class="line">    <span class="comment">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class="line">    <span class="comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">    <span class="comment">//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">    <span class="comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳回到前面是这个方法</span></span><br><span class="line">    <span class="comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                parkAndCheckInterrupt())</span></span><br><span class="line">    <span class="comment">//                interrupted = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class="line">    <span class="comment">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class="line">    <span class="comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span></span><br><span class="line">    <span class="comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;p&gt;AQS是JUC的核心组件，AQS引入了独占锁、共享锁等性质。首先，先来看看AQS的属性&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="AQS" scheme="https://zhongnf.github.io/tags/AQS/"/>
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码" scheme="https://zhongnf.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发：悲观锁机制</title>
    <link href="https://zhongnf.github.io/2021/12/09/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>https://zhongnf.github.io/2021/12/09/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%82%B2%E8%A7%82%E9%94%81/</id>
    <published>2021-12-09T12:57:30.000Z</published>
    <updated>2021-12-13T06:33:19.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><h4 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h4><p>在并发环境下，会出现多个线程对同一个资源进行争抢的情况。假设A资源正在修改，此时B线程又对资源进行修改，这就可能导致数据不一致问题。为了解决这一问题，就引入了锁机制，通过一把抽象的“锁”对资源进行锁定，当线程持有“锁”的时候，其他线程必须等待“锁”。</p><p>在Java中，主要采用两种实现方式，1.基于Object的悲观锁。2.基于CAS的乐观锁。</p><h2 id="对象、对象头结构"><a href="#对象、对象头结构" class="headerlink" title="对象、对象头结构"></a>对象、对象头结构</h2><p>锁是存储在对象头中的，那么对象和对象头的结果是什么呢？</p><p>Java对象发三部分：</p><ul><li>对象头</li><li>示例数据</li><li>对齐填充字节</li></ul><blockquote><p>其中对齐填充字节是为了满足“Java对象大小是8字节的倍数”而设计的。实例数据是你在初始化对象时设定的属性和状态等内容</p></blockquote><p>而对象头包含了两部分：</p><ul><li>Mark Word</li><li>Class Pointer</li></ul><p>Class Pointer是一个指针，指向当前对象类型所在方法区中的Class信息，Mark Word存储了很多当前对象的运行时状态信息，比如HashCode、锁状态标志、指向锁记录的指针、偏向线程ID、锁标记位等。</p><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211212204047537.png" alt="image-20211212204047537"></p><p>从图中最后两位代表锁标记位，分别对应对象锁的四种：无锁、偏向锁、轻量级锁、重量级锁。但是锁能升级，而不能将级。</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Synchronized关键字可用用来同步线程，Synchronized被编译后会生成moniterenter和moniterexit两个字节码，依赖着两个字节码指令进行线程同步。</p><h2 id="对象锁的四种状态"><a href="#对象锁的四种状态" class="headerlink" title="对象锁的四种状态"></a>对象锁的四种状态</h2><ol><li>无锁</li></ol><p>无锁顾名思义就是没有操作系统级别的资源(Mutex Lock)的锁定。在此基础上。我知道有两个语义上的“解锁”其实有两种语义。</p><p>第一种比较简单，有些资源不会出现在多线程环境中，甚至出现在多线程环境中的线程竞争也不会出现，所以真的不需要做任何同步来保护这个资源，让他直接对每个线程随机调用。这里，指语义上的。</p><p>另一种情况是，资源会竞争，但不使用操作系统同步原语来锁定共享资源，而是由一些其他机制来控制同步。如CAS，通过锁等功能级别，可以进行‘解锁’编程。顺便说一下，它还取决于操作系统对互斥锁性能差的原因进行了分析，所以在大多数情况下，没有锁更高效，但这并不意味着没有锁就可以完全取代锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是锁&quot;&gt;&lt;a href=&quot;#什么是锁&quot; class=&quot;headerlink&quot; title=&quot;什么是锁&quot;&gt;&lt;/a&gt;什么是锁&lt;/h2&gt;&lt;h4 id=&quot;锁的概念&quot;&gt;&lt;a href=&quot;#锁的概念&quot; class=&quot;headerlink&quot; title=&quot;锁的概念&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="多线程" scheme="https://zhongnf.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java并发系列" scheme="https://zhongnf.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    <category term="悲观锁" scheme="https://zhongnf.github.io/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM宋红康</title>
    <link href="https://zhongnf.github.io/2021/12/09/JVM/"/>
    <id>https://zhongnf.github.io/2021/12/09/JVM/</id>
    <published>2021-12-09T12:08:30.000Z</published>
    <updated>2021-12-09T12:10:04.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章-类加载子系统"></a>第2章-类加载子系统</h2><h3 id="一、内存结构概述"><a href="#一、内存结构概述" class="headerlink" title="一、内存结构概述"></a>一、内存结构概述</h3><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20210527163313814.png" alt="image-20210527163313814"></p><h3 id="二、类加载器子系统"><a href="#二、类加载器子系统" class="headerlink" title="二、类加载器子系统"></a>二、类加载器子系统</h3><p><strong>类加载器子系统作用：</strong></p><ol><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ol><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20210527163547782.png" alt="image-20210527163547782"></p><h3 id="三、类加载器ClassLoader角色"><a href="#三、类加载器ClassLoader角色" class="headerlink" title="三、类加载器ClassLoader角色"></a>三、类加载器ClassLoader角色</h3><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210527164134907.png" alt="image-20210527164134907"></p><h3 id="四、类加载过程"><a href="#四、类加载过程" class="headerlink" title="四、类加载过程"></a>四、类加载过程</h3><h4 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h4><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20210527164518519.png" alt="image-20210527164518519"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整流程：</p><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20210527164718372.png" alt="image-20210527164718372"></p><h4 id="4-2加载阶段"><a href="#4-2加载阶段" class="headerlink" title="4.2加载阶段"></a>4.2加载阶段</h4><p><strong>加载：</strong></p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h4 id="4-3连接阶段"><a href="#4-3连接阶段" class="headerlink" title="4.3连接阶段"></a>4.3连接阶段</h4><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保Class文件的字节流中包含的信息符合当前虚拟机要求，保证被加载类的正确性（元数据验证，文件格式验证，字节码验证，符合引用验证）</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul><li><p>为类变量分配内存并且设置该类变量的默认初始化值，即零值</p></li><li><p>不包含用final修饰的static，这是一个常量，会 直接分配好默认值</p></li><li><p>不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ul><li><strong>将符合引用转换为直接引用</strong></li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li></ul><h4 id="4-4初始化阶段"><a href="#4-4初始化阶段" class="headerlink" title="4.4初始化阶段"></a>4.4初始化阶段</h4><p><strong>Clinit()</strong></p><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ol><h3 id="五、类加载器的分类"><a href="#五、类加载器的分类" class="headerlink" title="五、类加载器的分类"></a>五、类加载器的分类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210527191651198.png" alt="image-20210527191651198"></p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><p><strong>（引导类加载器，Bootstrap ClassLoader）</strong></p><ol><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**<font color='red'>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</font>**</li></ol><h5 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h5><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>**<font color='red'>该类加载是程序中默认的类加载器</font>**，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><h5 id="什么时候需要"><a href="#什么时候需要" class="headerlink" title="什么时候需要"></a>什么时候需要</h5><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h5 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h5><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h4><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210528221902062.png" alt="image-20210528221902062"></p><h5 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h5><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210528222051896.png" alt="image-20210528222051896"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.null</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">            ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、双亲委派机制"><a href="#六、双亲委派机制" class="headerlink" title="六、双亲委派机制"></a>六、双亲委派机制</h3><h4 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h4><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li><font color='red'>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</font></li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210529151719489.png" alt="image-20210529151719489"></p><p><strong>当我们加载jdbc.jar 用于实现数据库连接的时候</strong></p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210529151904103.png" alt="image-20210529151904103"></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h3 id="七、沙箱安全机制"><a href="#七、沙箱安全机制" class="headerlink" title="七、沙箱安全机制"></a>七、沙箱安全机制</h3><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h3 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h3><h4 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h4><p><strong>两个必要条件</strong></p><ol><li>类的完整类名必须一致，包括包名</li><li><font color='red'><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></font></li></ol><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p><h4 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h4><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><font color='red'><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></font></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol><h2 id="第三章-运行时数据区概述及线程"><a href="#第三章-运行时数据区概述及线程" class="headerlink" title="第三章 运行时数据区概述及线程"></a>第三章 运行时数据区概述及线程</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一、运行时数据区结构"><a href="#一、运行时数据区结构" class="headerlink" title="一、运行时数据区结构"></a>一、运行时数据区结构</h3><h4 id="运行时数据与内存"><a href="#运行时数据与内存" class="headerlink" title="运行时数据与内存"></a>运行时数据与内存</h4><ol><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li><li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li></ol><h4 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h4><ol><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li><li>灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210529155055916.png" alt="image-20210529155055916"></p><h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><h3 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h3><h4 id="JVM线程"><a href="#JVM线程" class="headerlink" title="JVM线程"></a>JVM线程</h4><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><h3 id="三、程序计数器（PC寄存器）"><a href="#三、程序计数器（PC寄存器）" class="headerlink" title="三、程序计数器（PC寄存器）"></a>三、程序计数器（PC寄存器）</h3><h4 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h4><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210530131720084.png" alt="image-20210530131720084"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><h4 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h4><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210530131919147.png" alt="image-20210530131919147"></p><h4 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h4><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li></ol><h2 id="第四章-虚拟机栈"><a href="#第四章-虚拟机栈" class="headerlink" title="第四章 虚拟机栈"></a>第四章 虚拟机栈</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><h4 id="内存中的栈和堆"><a href="#内存中的栈和堆" class="headerlink" title="内存中的栈和堆"></a>内存中的栈和堆</h4><p><font color='red'>栈是运行时的单位，而堆是存储的单位。</font></p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p><h4 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h4><p>Java虚拟机栈是什么？</p><ul><li><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p></li><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h4 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h4><ul><li>是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>对于栈来说不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><h4 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h4><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</li></ul></li></ul><h4 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h4><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><h3 id="二、栈的存储单位"><a href="#二、栈的存储单位" class="headerlink" title="二、栈的存储单位"></a>二、栈的存储单位</h3><h4 id="栈中存储"><a href="#栈中存储" class="headerlink" title="栈中存储"></a>栈中存储</h4><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><ol><li>VM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210530143911293.png" alt="image-20210530143911293"></p><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables） </li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210530144140482.png" alt="image-20210530144140482"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><h4 id="局部变量表概述"><a href="#局部变量表概述" class="headerlink" title="局部变量表概述"></a>局部变量表概述</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><font color="red"><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong></font>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h4 id="关于变量槽Slot的理解"><a href="#关于变量槽Slot的理解" class="headerlink" title="关于变量槽Slot的理解"></a>关于变量槽Slot的理解</h4><ol><li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p></li><li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，</p><p>32位以内的类型只占用一个slot</p><p>（包括returnAddress类型），</p><p>64位的类型占用两个slot</p><p>（1ong和double）。</p><ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</p></li></ol><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li><font color="red">局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></li></ol><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><h3 id="栈缓存技术"><a href="#栈缓存技术" class="headerlink" title="栈缓存技术"></a>栈缓存技术</h3><ol><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ol><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ol><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h4><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h4><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h5 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h5><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><h5 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h5><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><h5 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h5><ol><li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li></ol><p><img src="C:\Users\znf\AppData\Roaming\Typora\typora-user-images\image-20210608170342705.png" alt="image-20210608170342705"></p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;h2 id=&quot;第2章-类加载子系统&quot;&gt;&lt;a href=&quot;#第2章-类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;第</summary>
      
    
    
    
    <category term="JVM" scheme="https://zhongnf.github.io/categories/JVM/"/>
    
    
    <category term="面试" scheme="https://zhongnf.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JVM" scheme="https://zhongnf.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Mysql面经35问</title>
    <link href="https://zhongnf.github.io/2021/12/09/Mysql/"/>
    <id>https://zhongnf.github.io/2021/12/09/Mysql/</id>
    <published>2021-12-09T12:07:30.000Z</published>
    <updated>2021-12-11T07:33:55.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql面经35问"><a href="#Mysql面经35问" class="headerlink" title="Mysql面经35问"></a>Mysql面经35问</h2><h2 id="1-说一说三大范式"><a href="#1-说一说三大范式" class="headerlink" title="1.说一说三大范式"></a>1.说一说三大范式</h2><ul><li><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</li><li><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被惟一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键</li><li><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息</li></ul><p>但是在我们的日常开发当中，<strong>「并不是所有的表一定要满足三大范式」</strong>，有时候冗余几个字段可以少关联几张表，带来的查询效率的提升有可能是质变的</p><h2 id="2-MyISAM-与-InnoDB-的区别是什么？"><a href="#2-MyISAM-与-InnoDB-的区别是什么？" class="headerlink" title="2.MyISAM 与 InnoDB 的区别是什么？"></a>2.MyISAM 与 InnoDB 的区别是什么？</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208162659957.png" alt="image-20211208162659957"></p><ul><li><ol><li><strong>「InnoDB支持事务，MyISAM不支持」</strong>。</li></ol></li><li><ol start="2"><li><strong>「InnoDB 支持外键，而 MyISAM 不支持」</strong>。</li></ol></li><li><ol start="3"><li><strong>「InnoDB是聚集索引」</strong>，使用B+Tree作为索引结构，数据文件是和索引绑在一起的，必须要有主键。<strong>「MyISAM是非聚集索引」</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li></ol></li><li><ol start="4"><li><strong>「InnoDB 不保存表的具体行数」</strong>。<strong>「MyISAM 用一个变量保存了整个表的行数」</strong>。</li></ol></li><li><ol start="5"><li>**Innodb 有 <strong>「redolog」</strong> 日志文件，MyISAM 没有</li></ol></li><li>6.<strong>「Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI」</strong><ul><li>Innodb：frm是表定义文件，ibd是数据文件</li><li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ul></li><li><ol start="7"><li><strong>「InnoDB 支持表、行锁，而 MyISAM 支持表级锁」</strong></li></ol></li><li>8、<strong>「InnoDB 必须有唯一索引(主键)」</strong>,如果没有指定的话 InnoDB 会自己生成一个隐藏列Row_id来充当默认主键，<strong>「MyISAM 可以没有」</strong></li></ul><h2 id="3-为什么推荐使用自增-id-作为主键？"><a href="#3-为什么推荐使用自增-id-作为主键？" class="headerlink" title="3.为什么推荐使用自增 id 作为主键？"></a>3.为什么推荐使用自增 id 作为主键？</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208162923881.png" alt="image-20211208162923881"></p><ul><li>１.普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会<strong>「导致普通索引的存储空间较大」</strong></li><li>２.使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接<strong>「按照顺序插入」</strong>，不用刻意维护</li><li>3.页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，<strong>「导致页分裂维护成本较高」</strong></li></ul><h2 id="4-一条查询语句是怎么执行的"><a href="#4-一条查询语句是怎么执行的" class="headerlink" title="4.一条查询语句是怎么执行的?"></a>4.一条查询语句是怎么执行的?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208162942078.png" alt="image-20211208162942078"></p><ol><li><p>通过连接器跟客户端<strong>「建立连接」</strong></p></li><li><p>通过查询<strong>「缓存查询」</strong>之前是否有查询过该 sql</p><ul><li><p>有则直接返回结果</p></li><li><p>没有则执行第三步</p></li></ul></li><li><p>通过分析器<strong>「分析该 sql 的语义」</strong>是否正确，包括格式，表等等</p></li><li><p>通过优化器<strong>「优化该语句」</strong>，比如选择索引，join 表的连接顺序</p></li><li><p><strong>「验证权限」</strong>，验证是否有该表的查询权限</p><ul><li>没有则返回无权限的错误</li><li>有则执行第六步</li></ul></li><li><p>通过执行器调用存储引擎执行该 sql，然后返回<strong>「执行结果」</strong></p></li></ol><h2 id="5-使用-Innodb-的情况下，一条更新语句是怎么执行的"><a href="#5-使用-Innodb-的情况下，一条更新语句是怎么执行的" class="headerlink" title="5.使用 Innodb 的情况下，一条更新语句是怎么执行的?"></a>5.使用 Innodb 的情况下，一条更新语句是怎么执行的?</h2><p>用以下语句来举例，c 字段无索引，id 为主键索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where id=2;</span><br></pre></td></tr></table></figure><ol><li><p>执行器先找引擎取 id=2 这一行。id 是主键，引擎直接用树搜索找到这一行</p><ul><li><p>如果 id=2 这一行所在的数据页本来就<strong>「在内存中」</strong>，就<strong>「直接返回」</strong>给执行器</p></li><li><p><strong>「不在内存」</strong>中，需要先从磁盘<strong>「读入内存」</strong>，然后再<strong>「返回」</strong></p></li></ul></li><li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口<strong>「写入这行新数据」</strong></p></li><li><p>引擎将这行新数据更新到内存中，同时将这个更新操作<strong>「记录到 redo log 里面」</strong>，此时 redo log 处于 <strong>「prepare」</strong> 状态。然后告知执行器执行完成了，随时可以提交事务</p></li><li><p>执行器<strong>「生成这个操作的 binlog」</strong>，并把 binlog <strong>「写入磁盘」</strong></p></li><li><p>执行器调用引擎的<strong>「提交事务」</strong>接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，<strong>「更新完成」</strong></p></li></ol><h2 id="6-Innodb-事务为什么要两阶段提交"><a href="#6-Innodb-事务为什么要两阶段提交" class="headerlink" title="6.Innodb 事务为什么要两阶段提交?"></a>6.Innodb 事务为什么要两阶段提交?</h2><ul><li>先写 redolog 后写binlog。假设在 redolog 写完，binlog 还没有写完的时候，MySQL 进程异常重启，这时候 binlog 里面就没有记录这个语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 <strong>「binlog 丢失」</strong>，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li>先写 binlog 后写 redolog。如果在 binlog 写完之后 crash，由于 redolog 还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是 binlog 里面已经记录了“把c从0改成1”这个日志。所以，在之后用 binlog 来恢复的时候就<strong>「多了一个事务出来」</strong>，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ul><p>可以看到，<strong>「如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致」</strong>。</p><h2 id="7-什么是索引"><a href="#7-什么是索引" class="headerlink" title="7.什么是索引?"></a>7.什么是索引?</h2><p>相信大家小时候学习汉字的时候都会查字典，想想你查字典的步骤，我们是通过汉字的首字母 a～z 一个一个在字典目录中查找，最终找到该字的页数。想想，如果没有目录会怎么样，最差的结果是你有可能翻到字典的最后一页才找到你想要找的字。</p><p>索引就<strong>「相当于我们字典中的目录」</strong>，可以极大的提高我们在数据库的查询效率。</p><h2 id="8-索引失效的场景有哪些"><a href="#8-索引失效的场景有哪些" class="headerlink" title="8.索引失效的场景有哪些?"></a>8.索引失效的场景有哪些?</h2><p>以下随便列举几个，不同版本的 mysql 场景不一</p><ol><li><p>最左前缀法则（带头索引不能死，中间索引不能断</p></li><li><p>不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描</p></li><li><p>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列，如：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a from user where c &gt; 5 and b = 4；</span><br></pre></td></tr></table></figure><ol start="4"><li><p>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</p></li><li><p>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描。</p></li><li><p>索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描，也是最左前缀原则。</p></li><li><p>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</p></li><li><p>索引字段使用 or 时，会导致索引失效而转向全表扫描</p></li></ol><h2 id="9-为什么采用-B-树-而不是-B-树"><a href="#9-为什么采用-B-树-而不是-B-树" class="headerlink" title="9.为什么采用 B+ 树,而不是 B-树"></a>9.为什么采用 B+ 树,而不是 B-树</h2><p>B+ 树只在叶子结点储存数据，非叶子结点不存具体数据，只存 key，查询更稳定，增大了广度，而一个节点就是磁盘一个内存页，内存页大小固定，那么相比 B 树，B- 树这些<strong>「可以存更多的索引结点」</strong>，宽度更大，树高矮，节点小，拉取一次数据的磁盘 IO 次数少，并且 B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，效率更高。</p><h2 id="10-WAl-是什么-有什么好处"><a href="#10-WAl-是什么-有什么好处" class="headerlink" title="10.WAl 是什么?有什么好处?"></a>10.WAl 是什么?有什么好处?</h2><p>WAL 就是 Write-Ahead Logging，其实就是<strong>「所有的修改都先被写入到日志中，然后再写磁盘」</strong>，用于保证数据操作的原子性和持久性。</p><p>好处:</p><ol><li><p><strong>「读和写可以完全地并发执行」</strong>，不会互相阻塞</p></li><li><p>先写入 log 中，磁盘写入从<strong>「随机写变为顺序写」</strong>，降低了 client 端的延迟就。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的 io 次数也大大降低</p></li><li><p>写入日志当数据库崩溃的时候<strong>「可以使用日志来恢复磁盘数据」</strong></p></li></ol><h2 id="11-什么是回表"><a href="#11-什么是回表" class="headerlink" title="11.什么是回表?"></a>11.什么是回表?</h2><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163033418.png" alt="image-20211208163033418" style="zoom:80%;" /><p>回表就是先通过数据库索引扫描出该索引树中数据所在的行，取到主键 id，再通过主键 id 取出主键索引数中的数据，即基于非主键索引的查询需要多扫描一棵索引树.</p><h2 id="12-什么是索引下推"><a href="#12-什么是索引下推" class="headerlink" title="12.什么是索引下推?"></a>12.什么是索引下推?</h2><p>如果存在某些被索引的列的判断条件时，MySQL 将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，<strong>「只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器」</strong> 。</p><h2 id="13-什么是覆盖索引"><a href="#13-什么是覆盖索引" class="headerlink" title="13.什么是覆盖索引?"></a>13.什么是覆盖索引?</h2><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取，可以减少回表的次数。比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where age = 1;</span><br></pre></td></tr></table></figure><p>id 为主键索引，age 为普通索引，age 这个索引树存储的就是逐渐信息，可以直接返回</p><h2 id="14-什么是最左前缀原则"><a href="#14-什么是最左前缀原则" class="headerlink" title="14.什么是最左前缀原则?"></a>14.什么是最左前缀原则?</h2><p>最左前缀其实说的是，在 where 条件中出现的字段，<strong>「如果只有组合索引中的部分列，则这部分列的触发索引顺序」</strong>，是按照定义索引的时候的顺序从前到后触发，最左面一个列触发不了，之后的所有列索引都无法触发。</p><p>比如<strong>「有一个 (a,b,c) 的组合索引」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where a = 1 and b = 1</span><br></pre></td></tr></table></figure><p>此时 a,b 会命中该组合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where a = 1 and c = 1</span><br></pre></td></tr></table></figure><p>此时 a 会命中该组合索引, c 不会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where b = 1 and c = 1</span><br></pre></td></tr></table></figure><p>此时不会命中该组合索引</p><h2 id="15-普通索引和唯一索引该怎么选择"><a href="#15-普通索引和唯一索引该怎么选择" class="headerlink" title="15.普通索引和唯一索引该怎么选择?"></a>15.普通索引和唯一索引该怎么选择?</h2><ul><li><p>查询</p><ul><li>当普通索引为条件时查询到数据会一直扫描,直到扫完整张表</li><li>当唯一索引为查询条件时,查到该数据会直接返回,不会继续扫表</li></ul></li><li><p>更新</p><ul><li>普通索引会直接将操作更新到 change buffer 中,然后结束</li><li>唯一索引需要判断数据是否冲突</li></ul></li></ul><p>所以<strong>「唯一索引更加适合查询的场景,普通索引更适合插入的场景」</strong></p><h2 id="16-什么是事务-其特性是什么"><a href="#16-什么是事务-其特性是什么" class="headerlink" title="16.什么是事务?其特性是什么?"></a>16.什么是事务?其特性是什么?</h2><p>事务是指是程序中一系列操作必须全部成功完成，有一个失败则全部失败。</p><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163108416.png" alt="image-20211208163108416"></p><p>特性</p><ul><li><strong>「1.原子性（Atomicity）」</strong>：要么全部执行成功，要么全部不执行。</li><li><strong>「2.一致性（Consistency）」</strong>：事务前后数据的完整性必须保持一致。</li><li><strong>「3.隔离性（Isolation）」</strong>：隔离性是当多个事务同事触发时，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li><strong>「4.持久性（Durability）」</strong>：事务完成之后的改变是永久的。</li></ul><h2 id="17-事务的隔离级别"><a href="#17-事务的隔离级别" class="headerlink" title="17.事务的隔离级别?"></a>17.事务的隔离级别?</h2><ol><li><p><strong>「读提交」</strong>:即能够<strong>「读取到那些已经提交」</strong>的数据</p></li><li><p><strong>「读未提交」</strong>:即能够<strong>「读取到没有被提交」</strong>的数据</p></li><li><p><strong>「可重复读」</strong>:可重复读指的是在一个事务内，最开始读到的数据和事务结束前的<strong>「任意时刻读到的同一批数据都是一致的」</strong></p></li><li><p><strong>「可串行化」</strong>:最高事务隔离级别，不管多少事务，都是<strong>「依次按序一个一个执行」</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163127482.png" alt="image-20211208163127482"></p><ul><li><strong>「脏读」</strong><ul><li>脏读指的是<strong>「读到了其他事务未提交的数据」</strong>，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读</li></ul></li><li><strong>「不可重复读」</strong><ul><li>对比可重复读，不可重复读指的是在同一事务内，<strong>「不同的时刻读到的同一批数据可能是不一样的」</strong>。</li></ul></li><li><strong>「幻读」</strong><ul><li>幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现<strong>「好像刚刚的更改对于某些数据未起作用」</strong>，但其实是事务B刚插入进来的这就叫幻读</li></ul></li></ul><h2 id="18-binlog-是做什么的"><a href="#18-binlog-是做什么的" class="headerlink" title="18.binlog 是做什么的?"></a>18.binlog 是做什么的?</h2><p>binlog 是归档日志，属于 Server 层的日志，是一个二进制格式的文件，用于<strong>「记录用户对数据库更新的SQL语句信息」</strong>。</p><p>主要作用</p><ul><li>主从复制</li><li>数据恢复</li></ul><h2 id="19-undolog-是做什么的"><a href="#19-undolog-是做什么的" class="headerlink" title="19.undolog 是做什么的?"></a>19.undolog 是做什么的?</h2><p>undolog 是 InnoDB 存储引擎的日志，用于保证数据的原子性，<strong>「保存了事务发生之前的数据的一个版本，也就是说记录的是数据是修改之前的数据，可以用于回滚」</strong>，同时可以提供多版本并发控制下的读（MVCC）。</p><p>主要作用</p><ul><li>事务回滚</li><li>实现多版本控制(MVCC)</li><li></li></ul><h2 id="20-relaylog-是做什么的"><a href="#20-relaylog-是做什么的" class="headerlink" title="20.relaylog 是做什么的?"></a>20.relaylog 是做什么的?</h2><p>relaylog 是中继日志，<strong>「在主从同步的时候使用到」</strong>，它是一个中介临时的日志文件，用于存储从master节点同步过来的binlog日志内容。</p><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163145058.png" alt="image-20211208163145058"></p><p>master 主节点的 binlog 传到 slave 从节点后，被写入 relay log 里，从节点的 slave sql 线程从 relaylog 里读取日志然后应用到 slave 从节点本地。从服务器 I/O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay-log 日志的内容并应用到从服务器，从而<strong>「使从服务器和主服务器的数据保持一致」</strong>。</p><h2 id="21-redolog-是做什么的"><a href="#21-redolog-是做什么的" class="headerlink" title="21.redolog 是做什么的?"></a>21.redolog 是做什么的?</h2><p>redolog 是 <strong>「InnoDB 存储引擎所特有的一种日志」</strong>，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。</p><p>可以做<strong>「数据恢复并且提供 crash-safe 能力」</strong></p><p>当有增删改相关的操作时，会先记录到 Innodb 中，并修改缓存页中的数据，<strong>「等到 mysql 闲下来的时候才会真正的将 redolog 中的数据写入到磁盘当中」</strong>。</p><h2 id="22-redolog-是怎么记录日志的"><a href="#22-redolog-是怎么记录日志的" class="headerlink" title="22.redolog 是怎么记录日志的?"></a>22.redolog 是怎么记录日志的?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163204717.png" alt="image-20211208163204717"></p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。<strong>「从头开始写，写到末尾就又回到开头循环写」</strong>。</p><p>所以，如果数据写满了但是还没有来得及将数据真正的刷入磁盘当中，那么就会发生<strong>「内存抖动」</strong>现象，从肉眼的角度来观察会发现 mysql 会宕机一会儿，此时就是正在刷盘了。</p><h2 id="23-redolog-和-binlog-的区别是什么"><a href="#23-redolog-和-binlog-的区别是什么" class="headerlink" title="23.redolog 和 binlog 的区别是什么?"></a>23.redolog 和 binlog 的区别是什么?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163217802.png" alt="image-20211208163217802"></p><ol><li><p><strong>「redolog」</strong> 是 <strong>「Innodb」</strong> 独有的日志，而 <strong>「binlog」</strong> 是 <strong>「server」</strong> 层的，所有的存储引擎都有使用到</p></li><li><p><strong>「redolog」</strong> 记录了<strong>「具体的数值」</strong>，对某个页做了什么修改，<strong>「binlog」</strong> 记录的<strong>「操作内容」</strong></p></li><li><p><strong>「binlog」</strong> 大小达到上限或者 flush log <strong>「会生成一个新的文件」</strong>，而 <strong>「redolog」</strong> 有固定大小<strong>「只能循环利用」</strong></p></li><li><p><strong>「binlog 日志没有 crash-safe 的能力」</strong>，只能用于归档。而 redo log 有 crash-safe 能力。</p></li></ol><h2 id="24-说一说-mvcc-吧，有什么作用"><a href="#24-说一说-mvcc-吧，有什么作用" class="headerlink" title="24.说一说 mvcc 吧，有什么作用?"></a>24.说一说 mvcc 吧，有什么作用?</h2><p>MVCC:多版本并发控制，是现代数据库(包括 MySQL、Oracle、PostgreSQL 等)引擎实现中常用的处理读写冲突的手段，目的在于<strong>「提高数据库高并发场景下的吞吐性能」</strong>。</p><p>在 MVCC 协议下，每个读操作会看到一个一致性的快照，<strong>「这个快照是基于整个库的」</strong>，并且可以实现非阻塞的读，用于<strong>「支持读提交和可重复读隔离级别的实现」</strong>。</p><p>MVCC 允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务 ID，在同一个时间点，不同的事务看到的数据是不同的，这个修改的数据是<strong>「记录在 undolog 中」</strong>的。</p><h2 id="25-一条-Sql-语句查询一直慢会是什么原因"><a href="#25-一条-Sql-语句查询一直慢会是什么原因" class="headerlink" title="25.一条 Sql 语句查询一直慢会是什么原因?"></a>25.一条 Sql 语句查询一直慢会是什么原因?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163231232.png" alt="image-20211208163231232"></p><ul><li><strong>「1.没有用到索引」</strong><ul><li>比如函数导致的索引失效，或者本身就没有加索引</li></ul></li><li><strong>「2.表数据量太大」</strong><ul><li>考虑分库分表吧</li></ul></li><li><strong>「3.优化器选错了索引」</strong><ul><li><strong>「考虑使用」</strong> force index 强制走索引</li></ul></li></ul><h2 id="26-一条-Sql-语句查询偶尔慢会是什么原因"><a href="#26-一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="26.一条 Sql 语句查询偶尔慢会是什么原因?"></a>26.一条 Sql 语句查询偶尔慢会是什么原因?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163243423.png" alt="image-20211208163243423"></p><ul><li><strong>「1. 数据库在刷新脏页」</strong><ul><li>比如 <strong>「redolog 写满了」</strong>，<strong>「内存不够用了」</strong>释放内存如果是脏页也需要刷，mysql <strong>「正常空闲状态刷脏页」</strong></li></ul></li><li><strong>「2. 没有拿到锁」</strong></li></ul><h2 id="27-Mysql-主从之间是怎么同步数据的"><a href="#27-Mysql-主从之间是怎么同步数据的" class="headerlink" title="27.Mysql 主从之间是怎么同步数据的?"></a>27.Mysql 主从之间是怎么同步数据的?</h2><ol><li><p>master 主库将此次更新的事件类型<strong>「写入到主库的 binlog 文件」</strong>中</p></li><li><p>master <strong>「创建 log dump 线程通知 slave」</strong> 需要更新数据</p></li><li><p><strong>「slave」</strong> 向 master 节点发送请求，<strong>「将该 binlog 文件内容存到本地的 relaylog 中」</strong></p></li><li><p><strong>「slave 开启 sql 线程」</strong>读取 relaylog 中的内容，<strong>「将其中的内容在本地重新执行一遍」</strong>，完成主从数据同步</p></li></ol><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/640" alt="图片"></p><p><strong>「同步策略」</strong>：</p><ol><li><p><strong>「全同步复制」</strong>：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差</p></li><li><p><strong>「半同步复制」</strong>：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回ack确认</p></li></ol><h2 id="28-主从延迟要怎么解决"><a href="#28-主从延迟要怎么解决" class="headerlink" title="28.主从延迟要怎么解决?"></a>28.主从延迟要怎么解决?</h2><ol><li><p>MySQL 5.6 版本以后，提供了一种<strong>「并行复制」</strong>的方式，通过将 SQL 线程转换为多个 work 线程来进行重放</p></li><li><p><strong>「提高机器配置」</strong>(王道)</p></li><li><p>在业务初期就选择合适的分库、分表策略，<strong>「避免单表单库过大」</strong>带来额外的复制压力</p></li><li><p><strong>「避免长事务」</strong></p></li><li><p><strong>「避免让数据库进行各种大量运算」</strong></p></li><li><p>对于一些对延迟很敏感的业务<strong>「直接使用主库读」</strong></p></li></ol><h2 id="29-删除表数据后表的大小却没有变动-这是为什么"><a href="#29-删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="29.删除表数据后表的大小却没有变动,这是为什么?"></a>29.删除表数据后表的大小却没有变动,这是为什么?</h2><p>在使用 delete 删除数据时，其实对应的数据行并不是真正的删除，是<strong>「逻辑删除」</strong>，InnoDB 仅仅是将其<strong>「标记成可复用的状态」</strong>，所以表空间不会变小</p><h2 id="30-为什么-VarChar-建议不要超过255"><a href="#30-为什么-VarChar-建议不要超过255" class="headerlink" title="30.为什么 VarChar 建议不要超过255?"></a>30.为什么 VarChar 建议不要超过255?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163302619.png" alt="image-20211208163302619"></p><p>当定义varchar长度小于等于255时，长度标识位需要一个字节(utf-8编码)</p><p>当大于255时，长度标识位需要两个字节，并且建立的<strong>「索引也会失效」</strong></p><h2 id="31-分布式式事务怎么实现"><a href="#31-分布式式事务怎么实现" class="headerlink" title="31.分布式式事务怎么实现?"></a>31.分布式式事务怎么实现?</h2><ol><li><p><strong>「本地消息表」</strong></p></li><li><p><strong>「消息事务」</strong></p></li><li><p><strong>「二阶段提交」</strong></p></li><li><p><strong>「三阶段提交」</strong></p></li><li><p><strong>「TCC」</strong></p></li><li><p><strong>「最大努力通知」</strong></p></li><li><p><strong>「Seata 框架」</strong></p></li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjA4ODcxNQ==&mid=2247497900&idx=1&sn=bc852ce0d95cba8e38b88bd2c770fb61&chksm=c2cacfc8f5bd46dec369e3ae19fd38a1f1c84c865166128888b898d1fb7d13749c5bcce32561&token=794819504&lang=zh_CN&scene=21#wechat_redirect">七种分布式事务的解决方案，一次讲给你听</a></p><h2 id="32-Mysql-中有哪些锁"><a href="#32-Mysql-中有哪些锁" class="headerlink" title="32.Mysql 中有哪些锁?"></a>32.Mysql 中有哪些锁?</h2><p>以下并不全，主要理解下锁的意义即可</p><ul><li>基于锁的属性分类：共享锁、排他锁</li><li>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁</li><li>基于锁的状态分类：意向共享锁、意向排它锁、死锁</li></ul><h2 id="33-为什么不要使用长事务"><a href="#33-为什么不要使用长事务" class="headerlink" title="33.为什么不要使用长事务?"></a>33.为什么不要使用长事务?</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163313429.png" alt="image-20211208163313429"></p><ol><li><p>并发情况下，数据库<strong>「连接池容易被撑爆」</strong></p></li><li><p><strong>「容易造成大量的阻塞和锁超时」</strong></p><ul><li>长事务还占用锁资源，也可能拖垮整个库，</li></ul></li><li><p>执行时间长，容易造成<strong>「主从延迟」</strong></p></li><li><p><strong>「回滚所需要的时间比较长」</strong></p><ul><li>事务越长整个时间段内的事务也就越多</li></ul></li><li><p><strong>「undolog 日志越来越大」</strong></p><ul><li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li><li></li></ul></li></ol><h2 id="34-buffer-pool-是做什么的"><a href="#34-buffer-pool-是做什么的" class="headerlink" title="34.buffer pool 是做什么的?"></a>34.buffer pool 是做什么的?</h2><p>buffer pool 是一块内存区域，为了<strong>「提高数据库的性能」</strong>，当数据库操作数据的时候，把硬盘上的数据加载到 buffer pool，不直接和硬盘打交道，操作的是 buffer pool 里面的数据，数据库的增删改查都是在 buffer pool 上进行</p><p>buffer pool 里面缓存的数据内容也是一个个数据页</p><p>其中<strong>「有三大双向链表」</strong>:</p><ul><li><strong>「free 链表」</strong><ul><li>用于帮助我们找到空闲的缓存页</li></ul></li><li><strong>「flush 链表」</strong><ul><li>用于找到脏缓存页，也就是需要刷盘的缓存页</li></ul></li><li><strong>「lru 链表」</strong><ul><li>用来淘汰不常被访问的缓存页，分为热数据区和冷数据区，冷数据区主要存放那些不常被用到的数据</li></ul></li></ul><p>预读机制:</p><ul><li>Buffer Pool 有一项特技叫预读，存储引擎的接口在被 Server 层调用时，会在响应的同时进行预判，将下次可能用到的数据和索引加载到 Buffer Pool</li></ul><h2 id="35-说说你的-Sql-调优思路吧"><a href="#35-说说你的-Sql-调优思路吧" class="headerlink" title="35.说说你的 Sql 调优思路吧"></a>35.说说你的 Sql 调优思路吧</h2><p><img src="https://raw.githubusercontent.com/zhongnf/MyTypora/main/img/image-20211208163324744.png" alt="image-20211208163324744"></p><ol><li><p><strong>「表结构优化」</strong></p><ul><li>1.1拆分字段</li><li>1.2字段类型的选择</li><li>1.3字段类型大小的限制</li><li>1.4合理的增加冗余字段</li><li>1.5新建字段一定要有默认值</li></ul></li><li><p><strong>「索引方面」</strong></p><ul><li>2.1索引字段的选择</li><li>2.2利用好mysql支持的索引下推，覆盖索引等功能</li><li>2.3唯一索引和普通索引的选择</li></ul></li><li><p><strong>「查询语句方面」</strong></p><ul><li>3.1避免索引失效</li><li>3.2合理的书写where条件字段顺序</li><li>3.3小表驱动大表</li><li>3.4可以使用force index()防止优化器选错索引</li></ul></li><li><p><strong>「分库分表」</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mysql面经35问&quot;&gt;&lt;a href=&quot;#Mysql面经35问&quot; class=&quot;headerlink&quot; title=&quot;Mysql面经35问&quot;&gt;&lt;/a&gt;Mysql面经35问&lt;/h2&gt;&lt;h2 id=&quot;1-说一说三大范式&quot;&gt;&lt;a href=&quot;#1-说一说三大范式&quot; c</summary>
      
    
    
    
    <category term="数据库" scheme="https://zhongnf.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://zhongnf.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="sql" scheme="https://zhongnf.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhongnf.github.io/2021/12/09/hello-world/"/>
    <id>https://zhongnf.github.io/2021/12/09/hello-world/</id>
    <published>2021-12-09T11:21:41.104Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
