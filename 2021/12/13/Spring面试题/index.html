<h2 id="1-谈谈你对spring的理解"><a href="#1-谈谈你对spring的理解" class="headerlink" title="1. 谈谈你对spring的理解"></a>1. 谈谈你对spring的理解</h2><p>spring是一个容器，spring帮我们起到了IOC容器的作用，用来承载我们整体的bean对象。它帮我们实现了整个bean对象从创建到销毁的整个生命周期管理。我们在使用spring的时候可以使用配置文件，也可以使用注解的方式，但是，当我们程序开始驱动之后，我要把注解或者配置文件定义好的Bean对象转换成beanDefination，然后完成这个beanDefination的解析和加载的过程。当获取到这些完整的对象之后，要对整个beanDefination实现实例化操作，在实例化的时候，最简单的方式，是通过反射的方式来创建对象。当创建对象之后，还会实现一些接口等操作，如果要实现aop还要执行一些beanPropset，当对象创建之后就可直接调用了。</p>
<h2 id="2-什么是控制反转（IOC）？什么是依赖注入？"><a href="#2-什么是控制反转（IOC）？什么是依赖注入？" class="headerlink" title="2. 什么是控制反转（IOC）？什么是依赖注入？"></a>2. 什么是控制反转（IOC）？什么是依赖注入？</h2><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象 实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。在Java中有三种实现方式</p>
<ol>
<li>构造器注入</li>
<li>Setter方法注入</li>
<li>接口注入</li>
</ol>
<h2 id="3-BeanFactory-和-ApplicationContext-有什么区别？"><a href="#3-BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="3. BeanFactory 和 ApplicationContext 有什么区别？"></a>3. BeanFactory 和 ApplicationContext 有什么区别？</h2><p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便 在接收到客户端请求时将对应的 bean 实例化。 BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的 配置中解放出来。BeanFactory 还包含 了 bean 生命周期的控制，调用客户端的初始化方法 （initialization methods）和销毁方法（destruction methods）。</p>
<ol>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 </li>
<li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册</li>
</ol>
<h2 id="4-BeanFactory生命周期"><a href="#4-BeanFactory生命周期" class="headerlink" title="4.BeanFactory生命周期"></a>4.BeanFactory生命周期</h2><h2 id="5-AOP底层原理"><a href="#5-AOP底层原理" class="headerlink" title="5. AOP底层原理"></a>5. AOP底层原理</h2><p>Aop:即面向切面编程，能够让我们在不影响原有功能的前提下，为软件<strong>横向扩展</strong>功能。其底层使用了动态代理（JDK动态代理和CGLB动态代理）</p>
<h3 id="5-1-动态代理原理区别"><a href="#5-1-动态代理原理区别" class="headerlink" title="5.1 动态代理原理区别"></a>5.1 动态代理原理区别</h3><p>jdk动态代理是利用反射机制生成一个实现代理接口的匿名类，在具体方法调用前调用invokerHandler进行处理。</p>
<p>cglib动态代理对代理对象类的class文件加载起来，通过修改字节码生成子类来处理</p>
<p>区别：</p>
<ol>
<li>如果目标对象实现了接口，默认情况下采用JDK动态代理实现AOP。</li>
<li>如果目标对象实现了接口，可以强制CGLIB实现AOP。（设置proxy-target-class为true）</li>
<li>如果目标对象没有实现接口，必须使用CGLIB实现AOP。</li>
</ol>
<h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><p>用户管理接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delUser</span><span class="params">(String user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户管理实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImp</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">user</span><span class="params">(String userName,Stirng password)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUser</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throw Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理，调用方法前&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法结束&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getJDKProxy</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = targetObject;</span><br><span class="line">        <span class="comment">//JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdkProxy jdkProxy = <span class="keyword">new</span> JdkProxy();<span class="comment">//实例化JDKProxy对象</span></span><br><span class="line">        UserManager user = (UserManager) jdkProxy.getJDKProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.addUser(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123123&quot;</span>);<span class="comment">//执行新增方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cglib动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cglib动态代理，实现MethodInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arr, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib动态代理，监听开始！&quot;</span>);</span><br><span class="line">        Object invoke = method.invoke(target, arr);<span class="comment">//方法执行，参数：target 目标对象 arr参数数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib动态代理，监听结束！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object objectTarget)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">// 设置回调 </span></span><br><span class="line">        Object result = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();<span class="comment">//实例化CglibProxy对象</span></span><br><span class="line">        UserManager user =  (UserManager) cglib.getCglibProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.delUser(<span class="string">&quot;admin&quot;</span>);<span class="comment">//执行删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-使用步骤"><a href="#5-3-使用步骤" class="headerlink" title="5.3 使用步骤"></a>5.3 使用步骤</h3><ol>
<li>@EnableAspectJAutoProxy 开启基于注解的aop模式</li>
<li>@Aspect：定义切面类，切面类里定义通知</li>
<li>@PointCut 切入点，可以写切入点表达式，指定在哪个方法切入</li>
<li>通知方法<ul>
<li>@Before(前置通知)</li>
<li>@After(后置通知)</li>
<li>@AfterReturning(返回通知)</li>
<li>@AfterTrowing(异常通知)@Around(环绕通知)</li>
</ul>
</li>
<li>JoinPoint：连接点,是一个类，配合通知使用，用于获取切入的点的信息</li>
</ol>
<h3 id="5-4-SpringAop原理"><a href="#5-4-SpringAop原理" class="headerlink" title="5.4 SpringAop原理"></a>5.4 SpringAop原理</h3><ol>
<li>@EnableAspectJAutoProxy<ul>
<li>@EnableAspectJAutoProxy 通过@Import(AspectJAutoProxyRegistrar.class)给spring容器中导入了一个AnnotationAwareAspectJAutoProxyCreator。</li>
<li>AnnotationAwareAspectJAutoProxyCreator实现了InstantiationAwareBeanPostProcessor,InstantiationAwareBeanPostProcessor是一个BeanPostProcessor。它可以拦截spring的Bean初始化(Initialization)前后和实例化(Initialization)前后。</li>
</ul>
</li>
<li>AnnotationAwareAspectJAutoProxyCreator的postProcessBeforeInstantiation(bean实例化前)：会通过调用isInfrastructureClass(beanClass)来判断 被拦截的类是否是基础类型的Advice、PointCut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect），若是则放入adviseBean集合。这里主要是用来处理我们的切面类。</li>
<li>AnnotationAwareAspectJAutoProxyCreator的BeanPostProcessorsAfterInitialization（bean初始化后）：<ol>
<li>首先找到被拦截的Bean的匹配的增强器（通知方法），这里有切入点表达式匹配的逻辑</li>
<li>将增强器保存到proxyFactory中，</li>
<li>根据被拦截的Bean是否实现了接口，spring自动决定使用JdkDynamicAopProxy还是ObjenesisCglibAopProxy</li>
<li>最后返回被拦截的Bean的代理对象，注册到spring容器中</li>
</ol>
</li>
<li>代理Bean的目标方法执行过程：CglibAopProxy.intercept();<ol>
<li>保存所有的增强器，并处理转换为一个拦截器链</li>
<li>如果没有拦截器链，就直接执行目标方法</li>
<li>如果有拦截器链，就将目标方法，拦截器链等信息传入并创建CglibMethodInvocation对象，并调用proceed()方法获取返回值。proceed方法内部会依次执行拦截器链。</li>
</ol>
</li>
</ol>
<h2 id="6-beanFactory-getBean方法执行的过程"><a href="#6-beanFactory-getBean方法执行的过程" class="headerlink" title="6. beanFactory.getBean方法执行的过程"></a>6. beanFactory.getBean方法执行的过程</h2>